<html>
<head>

</head>
<body style="padding: 0; margin: 0">


<canvas id="canvas" width="800" height="600" 
	style="
		width: 100%; height: 100%;
		grid-column: 1; grid-row: 1">
</canvas>

<span style="position: fixed; z-index: 100; left: 10px; top: 10px;">
	
</span>

<script src="./libs/gl-matrix.js"></script>
<script src="./libs/dat.gui.min.js"></script>




<script type="module" async>
	
	
	import {Geometry} from "./src/Geometry.js";
	import {Mesh} from "./src/scene/Mesh.js";
	import {Pointcloud} from "./src/scene/Pointcloud.js";
	import {Vector3} from "./src/math/Vector3.js";
	import {Matrix4} from "./src/math/Matrix4.js";
	import {Lines} from "./src/scene/Lines.js";
	import {Potree} from "./src/Potree.js";
	import {SceneNode} from "./src/scene/SceneNode.js";

	window.debug = {
		"#nodes": "0",
		"#points": "0",
		fps: "0",
		displayBoxes: false,
		freeze: false,
		attribute: "rgb",
		minNodeSize: 0.2,
		loaded: "0",
	};

	window.onload = function() {
		let gui = new dat.GUI();
		gui.add(debug, '#nodes').listen();
		gui.add(debug, '#points').listen();
		gui.add(debug, 'fps').listen();
		gui.add(debug, 'displayBoxes');
		gui.add(debug, 'freeze');
		gui.add(debug, 'attribute', { rgb: "rgb", intensity: "intensity"});
		gui.add(debug, 'minNodeSize', 0.01, 0.5);
		gui.add(debug, 'loaded').listen();
		// gui.add(text, 'explode');
	};

	class TestCloud extends SceneNode{
		constructor(name, geometry){
			super(name);

			this.geometry = geometry;
		}
	}

	let vs = `
		#version 450

		layout(set = 0, binding = 0) uniform Uniforms {
			mat4 worldViewProj;
		} uniforms;

		layout(location = 0) in vec3 a_position;
		layout(location = 1) in ivec4 a_rgb;

		layout(location = 0) out vec4 vColor;

		vec3 getColor(){
			vec3 rgb = vec3(a_rgb.xyz);
			if(length(rgb) > 2.0){
				rgb = rgb / 256.0;
			}
			if(length(rgb) > 2.0){
				rgb = rgb / 256.0;
			}
			return rgb;
		}

		void main() {
			vColor = vec4(getColor(), 1.0);

			gl_Position = uniforms.worldViewProj * vec4(a_position, 1.0);
		}
	`;

	let fs = `

		#version 450

		layout(location = 0) in vec4 vColor;
		layout(location = 0) out vec4 outColor;

		void main() {
			//outColor = vColor;
			//outColor = vec4(vColor.xyz / 256.0, 1.0);
			outColor = vec4(1.0, 0.0, 0.0, 1.0);
		}

	`;



	let canvas = document.getElementById("canvas");
	new Potree().init(canvas).then((viewer) => {
		window.potree = viewer;

		let {scene, renderer} = viewer;
		window.scene = scene;

		viewer.controls.yaw = 0.5558419226453803;
		viewer.controls.pitch = -0.6999490877756642;
		viewer.controls.radius = 5;
		viewer.controls.target.set(0, 0, 0);
		

		viewer.addListener("update", (e) => {
			window.debug.fps = Math.round(viewer.fps) + "";
		});



		let {device} = renderer;

		let shader = {
			vsModule: renderer.makeShaderModule('vertex', vs),
			fsModule: renderer.makeShaderModule('fragment', fs),
		};

		let bindGroupLayout = device.createBindGroupLayout({
			entries: [{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: "uniform-buffer"
			}]
		});

		let pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });

		let pipeline = device.createRenderPipeline({
			layout: pipelineLayout,
			vertexStage: {
				module: shader.vsModule,
				entryPoint: 'main'
			},
			fragmentStage: {
				module: shader.fsModule,
				entryPoint: 'main'
			},
			vertexState: { 
				vertexBuffers: [{
					arrayStride: 16,
					attributes: [{
						shaderLocation: 0,
						offset: 0,
						format: "float3",
					}],
				},{
					arrayStride: 16,
					attributes: [{
						shaderLocation: 1,
						offset: 12,
						format: "uchar4",
					}],
				}]
			},
			colorStates: [{
				format: renderer.swapChainFormat,
			}],
			primitiveTopology: 'point-list',
			depthStencilState: {
				depthWriteEnabled: true,
				depthCompare: "less",
				format: "depth24plus-stencil8",
			}
		});

		const uniformBufferSize = 64;

		let buffer = device.createBuffer({
			size: uniformBufferSize,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
		});

		let bindGroup = device.createBindGroup({
			layout: bindGroupLayout,
			entries: [{
				binding: 0,
				resource: {
					buffer: buffer,
				},
			}],
		});

		let uniforms = {
			buffer: buffer,
			bindGroup: bindGroup,
			bindGroupLayout: bindGroupLayout,
		};



		let n = 10_000_000;
		let position = new Float32Array(3 * n);
		let color = new Uint8Array(4 * n);

		let π = Math.PI;
		let {abs, cos, sin, random, min, max} = Math;
		let clamp = (v, a, b) => Math.min(Math.max(v, a), b);

		for(let i = 0; i < n; i++){
			let x = random() * 2 - 1;
			let y = random() * 2 - 1;
			let z = 0.5 * cos(π * y) * cos(π * x);

			let r = parseInt(clamp(255 * (z + 0.5), 0, 255));
			let g = 0;
			let b = 0;

			position[3 * i + 0] = x;
			position[3 * i + 1] = y;
			position[3 * i + 2] = z;

			
			color[4 * i + 0] = r;
			color[4 * i + 1] = g;
			color[4 * i + 2] = b;
			color[4 * i + 3] = 255;
		}

		const [gpubuffer, arraybuffer] = device.createBufferMapped({
			size: 16 * n,
			usage: GPUBufferUsage.VERTEX
		});

		{
			let target = new DataView(arraybuffer);

			for(let i = 0; i < n; i++){
				target.setFloat32(16 * i + 0, position[3 * i + 0], true);
				target.setFloat32(16 * i + 4, position[3 * i + 1], true);
				target.setFloat32(16 * i + 8, position[3 * i + 2], true);

				target.setUint8(16 * i + 12, color[4 * i + 0]);
				target.setUint8(16 * i + 13, color[4 * i + 1]);
				target.setUint8(16 * i + 14, color[4 * i + 2]);
				target.setUint8(16 * i + 15, color[4 * i + 3]);
			}
		}
		gpubuffer.unmap();

		
		let buffers = [
			// {name: "position", array: position},
			// {name: "color", array: color},
		];
		let geometry = new Geometry(n, buffers);

		let pointcloud = new TestCloud("test", geometry);

		scene.root.add(pointcloud);



		let renderTestCloud = (pointcloud, view, proj, state) => {
			let transform = new Matrix4();
			let scale = new Matrix4();
			let translate = new Matrix4();
			let worldView = new Matrix4();
			let worldViewProj = new Matrix4();

			scale.makeScale(pointcloud.scale.x, pointcloud.scale.y, pointcloud.scale.z);
			translate.makeTranslation(pointcloud.position.x, pointcloud.position.y, pointcloud.position.z);
			transform.multiplyMatrices(translate, scale);
			worldView.multiplyMatrices(view, transform);
			worldViewProj.multiplyMatrices(proj, worldView);


			let commandEncoder = device.createCommandEncoder();

			let passEncoder = commandEncoder.beginRenderPass(state.renderPassDescriptor);
			passEncoder.setPipeline(pipeline);

			uniforms.buffer.setSubData(0, new Float32Array(worldViewProj.elements));

			passEncoder.setVertexBuffer(0, gpubuffer);
			passEncoder.setVertexBuffer(1, gpubuffer);

			passEncoder.setBindGroup(0, uniforms.bindGroup);

			passEncoder.draw(n, 1, 0, 0);

			passEncoder.endPass();

			device.defaultQueue.submit([commandEncoder.finish()]);

		};

		renderer.nodeRenderers["TestCloud"] = renderTestCloud.bind(renderer);




	});

	


</script>



</body>
</html>